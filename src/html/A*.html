<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Solver using A*</title>
    <style>
      .maze {
        display: grid;
        grid-template-columns: repeat(9, 30px);
        grid-template-rows: repeat(11, 30px);
      }
      .cell {
        width: 30px;
        height: 30px;
        border: 1px solid black;
      }
      .wall {
        background-color: black;
      }
      .start {
        background-color: green;
      }
      .goal {
        background-color: red;
      }
      .path {
        background-color: yellow;
      }
      .open {
        background-color: lightblue;
      }
      .closed {
        background-color: lightcoral;
      }
    </style>
  </head>
  <body>
    <div class="maze" id="maze"></div>
    <button onclick="solveMaze()">Solve Maze</button>

    <script>
      const maze = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 1, 0],
        [0, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 1, 0, 0, 0, 1, 0, 0, 0],
        [0, 1, 0, 0, 0, 1, 1, 0, 0],
        [0, 1, 0, 0, 0, 1, 0, 0, 0],
        [0, 1, 0, 0, 0, 1, 0, 1, 0],
        [3, 1, 0, 0, 0, 1, 2, 1, 0],
        [1, 1, 0, 1, 1, 1, 1, 1, 0],
        [1, 0, 0, 0, 0, 0, 0, 0, 0],
      ];

      const startNode = findNode(maze, 2);
      const goalNode = findNode(maze, 3);
      let interval;

      function findNode(maze, value) {
        for (let i = 0; i < maze.length; i++) {
          for (let j = 0; j < maze[i].length; j++) {
            if (maze[i][j] === value) {
              return [i, j];
            }
          }
        }
        return null;
      }

      class Node {
        constructor(position, g, h, f, parent) {
          this.position = position;
          this.g = g;
          this.h = h;
          this.f = f;
          this.parent = parent;
        }
      }

      function heuristic(a, b) {
        return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
      }

      function getNeighbors(node) {
        const [x, y] = node.position;
        const neighbors = [];
        if (x > 0) neighbors.push([x - 1, y]);
        if (x < maze.length - 1) neighbors.push([x + 1, y]);
        if (y > 0) neighbors.push([x, y - 1]);
        if (y < maze[0].length - 1) neighbors.push([x, y + 1]);
        return neighbors;
      }

      function aStar(start, goal) {
        const openSet = [];
        const closedSet = new Set();

        const startNode = new Node(start, 0, heuristic(start, goal), 0, null);
        openSet.push(startNode);

        const path = [];
        let found = false;

        interval = setInterval(() => {
          if (openSet.length === 0) {
            clearInterval(interval);
            alert("No path found!");
            return;
          }

          openSet.sort((a, b) => a.f - b.f);
          const currentNode = openSet.shift();
          closedSet.add(currentNode.position.toString());
          drawMaze(maze, openSet, closedSet, path);

          if (currentNode.position.toString() === goal.toString()) {
            let current = currentNode;
            while (current) {
              path.push(current.position);
              current = current.parent;
            }

            console.log("path:");
            console.log(path);
            drawMaze(maze, openSet, closedSet, path.reverse());
            clearInterval(interval);
            found = true;
            return;
          }

          for (const neighbor of getNeighbors(currentNode)) {
            if (
              closedSet.has(neighbor.toString()) ||
              maze[neighbor[0]][neighbor[1]] === 1
            ) {
              continue;
            }

            const g = currentNode.g + 1;
            const h = heuristic(neighbor, goal);
            const f = g + h;
            const existingNode = openSet.find(
              (node) => node.position.toString() === neighbor.toString()
            );

            if (!existingNode || g < existingNode.g) {
              const neighborNode = new Node(neighbor, g, h, f, currentNode);
              if (!existingNode) {
                openSet.push(neighborNode);
              } else {
                existingNode.g = g;
                existingNode.h = h;
                existingNode.f = f;
                existingNode.parent = currentNode;
              }
            }
          }
        }, 100);

        if (!found) {
          return [];
        }
      }

      function drawMaze(maze, openSet, closedSet, path) {
        const mazeElement = document.getElementById("maze");
        mazeElement.innerHTML = "";
        for (let i = 0; i < maze.length; i++) {
          for (let j = 0; j < maze[i].length; j++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            if (maze[i][j] === 1) {
              cell.classList.add("wall");
            } else if (maze[i][j] === 2) {
              cell.classList.add("start");
            } else if (maze[i][j] === 3) {
              cell.classList.add("goal");
            } else if (path.some((p) => p[0] === i && p[1] === j)) {
              cell.classList.add("path");
            } else if (
              openSet.some(
                (node) => node.position[0] === i && node.position[1] === j
              )
            ) {
              cell.classList.add("open");
            } else if (closedSet.has([i, j].toString())) {
              cell.classList.add("closed");
            }
            mazeElement.appendChild(cell);
          }
        }
      }

      function solveMaze() {
        aStar(startNode, goalNode);
      }

      drawMaze(maze, [], new Set(), []);
    </script>
  </body>
</html>
